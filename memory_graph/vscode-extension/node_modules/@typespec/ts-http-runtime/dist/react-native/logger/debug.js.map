{"version":3,"file":"debug.js","sourceRoot":"","sources":["../../../src/logger/debug.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { log } from \"./log.js\";\n\n/**\n * A simple mechanism for enabling logging.\n * Intended to mimic the publicly available `debug` package.\n */\nexport interface Debug {\n  /**\n   * Creates a new logger with the given namespace.\n   */\n  (namespace: string): Debugger;\n  /**\n   * The default log method (defaults to console)\n   */\n  log: (...args: any[]) => void;\n  /**\n   * Enables a particular set of namespaces.\n   * To enable multiple separate them with commas, e.g. \"info,debug\".\n   * Supports wildcards, e.g. \"typeSpecRuntime:*\"\n   * Supports skip syntax, e.g. \"typeSpecRuntime:*,-typeSpecRuntime:storage:*\" will enable\n   * everything under typeSpecRuntime except for things under typeSpecRuntime:storage.\n   */\n  enable: (namespaces: string) => void;\n  /**\n   * Checks if a particular namespace is enabled.\n   */\n  enabled: (namespace: string) => boolean;\n  /**\n   * Disables all logging, returns what was previously enabled.\n   */\n  disable: () => string;\n}\n\n/**\n * A log function that can be dynamically enabled and redirected.\n */\nexport interface Debugger {\n  /**\n   * Logs the given arguments to the `log` method.\n   */\n  (...args: any[]): void;\n  /**\n   * True if this logger is active and logging.\n   */\n  enabled: boolean;\n  /**\n   * Used to cleanup/remove this logger.\n   */\n  destroy: () => boolean;\n  /**\n   * The current log method. Can be overridden to redirect output.\n   */\n  log: (...args: any[]) => void;\n  /**\n   * The namespace of this logger.\n   */\n  namespace: string;\n  /**\n   * Extends this logger with a child namespace.\n   * Namespaces are separated with a ':' character.\n   */\n  extend: (namespace: string) => Debugger;\n}\n\nconst debugEnvVariable =\n  (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\n\nlet enabledString: string | undefined;\nlet enabledNamespaces: string[] = [];\nlet skippedNamespaces: string[] = [];\nconst debuggers: Debugger[] = [];\n\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\n\nconst debugObj: Debug = Object.assign(\n  (namespace: string): Debugger => {\n    return createDebugger(namespace);\n  },\n  {\n    enable,\n    enabled,\n    disable,\n    log,\n  },\n);\n\nfunction enable(namespaces: string): void {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const namespaceList = namespaces.split(\",\").map((ns) => ns.trim());\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(ns.substring(1));\n    } else {\n      enabledNamespaces.push(ns);\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\n\nfunction enabled(namespace: string): boolean {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n\n  for (const skipped of skippedNamespaces) {\n    if (namespaceMatches(namespace, skipped)) {\n      return false;\n    }\n  }\n  for (const enabledNamespace of enabledNamespaces) {\n    if (namespaceMatches(namespace, enabledNamespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Given a namespace, check if it matches a pattern.\n * Patterns only have a single wildcard character which is *.\n * The behavior of * is that it matches zero or more other characters.\n */\nfunction namespaceMatches(namespace: string, patternToMatch: string): boolean {\n  // simple case, no pattern matching required\n  if (patternToMatch.indexOf(\"*\") === -1) {\n    return namespace === patternToMatch;\n  }\n\n  let pattern = patternToMatch;\n\n  // normalize successive * if needed\n  if (patternToMatch.indexOf(\"**\") !== -1) {\n    const patternParts = [];\n    let lastCharacter = \"\";\n    for (const character of patternToMatch) {\n      if (character === \"*\" && lastCharacter === \"*\") {\n        continue;\n      } else {\n        lastCharacter = character;\n        patternParts.push(character);\n      }\n    }\n    pattern = patternParts.join(\"\");\n  }\n\n  let namespaceIndex = 0;\n  let patternIndex = 0;\n  const patternLength = pattern.length;\n  const namespaceLength = namespace.length;\n  let lastWildcard = -1;\n  let lastWildcardNamespace = -1;\n\n  while (namespaceIndex < namespaceLength && patternIndex < patternLength) {\n    if (pattern[patternIndex] === \"*\") {\n      lastWildcard = patternIndex;\n      patternIndex++;\n      if (patternIndex === patternLength) {\n        // if wildcard is the last character, it will match the remaining namespace string\n        return true;\n      }\n      // now we let the wildcard eat characters until we match the next literal in the pattern\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        // reached the end of the namespace without a match\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n\n      // now that we have a match, let's try to continue on\n      // however, it's possible we could find a later match\n      // so keep a reference in case we have to backtrack\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else if (pattern[patternIndex] === namespace[namespaceIndex]) {\n      // simple case: literal pattern matches so keep going\n      patternIndex++;\n      namespaceIndex++;\n    } else if (lastWildcard >= 0) {\n      // special case: we don't have a literal match, but there is a previous wildcard\n      // which we can backtrack to and try having the wildcard eat the match instead\n      patternIndex = lastWildcard + 1;\n      namespaceIndex = lastWildcardNamespace + 1;\n      // we've reached the end of the namespace without a match\n      if (namespaceIndex === namespaceLength) {\n        return false;\n      }\n      // similar to the previous logic, let's keep going until we find the next literal match\n      while (namespace[namespaceIndex] !== pattern[patternIndex]) {\n        namespaceIndex++;\n        if (namespaceIndex === namespaceLength) {\n          return false;\n        }\n      }\n      lastWildcardNamespace = namespaceIndex;\n      namespaceIndex++;\n      patternIndex++;\n      continue;\n    } else {\n      return false;\n    }\n  }\n\n  const namespaceDone = namespaceIndex === namespace.length;\n  const patternDone = patternIndex === pattern.length;\n  // this is to detect the case of an unneeded final wildcard\n  // e.g. the pattern `ab*` should match the string `ab`\n  const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === \"*\";\n  return namespaceDone && (patternDone || trailingWildCard);\n}\n\nfunction disable(): string {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\n\nfunction createDebugger(namespace: string): Debugger {\n  const newDebugger: Debugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend,\n  });\n\n  function debug(...args: any[]): void {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n\n  debuggers.push(newDebugger);\n\n  return newDebugger;\n}\n\nfunction destroy(this: Debugger): boolean {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\nfunction extend(this: Debugger, namespace: string): Debugger {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\n\nexport default debugObj;\n"]}